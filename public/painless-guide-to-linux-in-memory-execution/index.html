<link rel=stylesheet href=/css/custom.css><!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><title>Painless Guide to Linux in-Memory Execution &#183; pop-ecx</title><meta name=description content><link type=text/css rel=stylesheet href=https://pop-ecx.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://pop-ecx.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://pop-ecx.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://pop-ecx.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><script src=https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js></script>
<script>function addDarkmodeWidget(){new Darkmode({label:"ðŸŒ“",saveInCookies:!0,autoMatchOsTheme:!0,bottom:"32px",right:"32px",time:"0.3s",mixColor:"#fff",backgroundColor:"#fff"}).showWidget()}window.addEventListener("load",addDarkmodeWidget)</script></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=author-image><img src=/images/me.png alt="Author Image" class=author-image></div><div class=sidebar-about><a href=https://pop-ecx.github.io/><h1>pop-ecx</h1></a><p class=lead>Tech musings</p></div><div class=social-links><a href=https://github.com/pop-ecx target=_blank rel="noopener noreferrer"><img src=https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/github.svg width=24 height=24 alt=GitHub></a>
<a href=https://keybase.io/oliver_m target=_blank rel="noopener noreferrer"><img src=https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/keybase.svg width=24 height=24 alt=Keybase></a>
<a href=https://bsky.app/profile/pop-ecx.bsky.social target=_blank rel="noopener noreferrer"><img src=https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/bluesky.svg width=24 height=24 alt=Bluesky></a>
<a href=https://www.linkedin.com/in/oliver-mulwa target=_blank rel="noopener noreferrer"><img src=https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/linkedin.svg width=24 height=24 alt=LinkedIn></a></div><nav><ul class=sidebar-nav><li><a href=https://pop-ecx.github.io/>Home</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></nav><p>&copy; 2025. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Painless Guide to Linux in-Memory Execution</h1><time datetime=2025-12-04T08:21:15+0300 class=post-date>Thu, Dec 4, 2025</time><p>In-memory execution, a technique that allows programs to be run directly from
memory without being written to disk. Over the past few weeks, I&rsquo;ve been attempting
to learn and understand this concept better. In a previous <a href=https://pop-ecx.github.io/pack-to-the-futureobfuscating-my-c2-agent/>post</a>,
I explained my reasoning behind choosing ZYRA for obfuscation and packing. The
key reason behind I could take it to whichever direction I wanted, should
need arise.</p><p>Safe to say, need did arise. So in this post, we&rsquo;ll modify ZYRA to support in-memory
execution. How zyra unpacks, decrypts and executes the payload is beyond the scope
of this post. However, if you&rsquo;re interested in learning more, I would recommend
reading through its code. It&rsquo;s not super complex, and is very digestable.</p><p>One of the most directly accessible ways to achieve in-memory execution on Linux
is by leveraging the <code>memfd_create</code> syscall. This syscall allows us to create an
anonymous file in memory, which can then be executed without ever touching the disk.
You can read more about it by running <code>man memfd_create</code>.</p><p>Here&rsquo;s a basic outline of how we can implement in-memory eexecution using <code>memfd_create</code>:</p><ol><li><p><strong>Create a memory file descriptor</strong>: Use the <code>memfd_create</code> syscall to create
an anonymous memory file descriptor.</p></li><li><p><strong>Write the payload to memory</strong>: Write the unpacked and decrypted payload to
the memory file descriptor.</p></li><li><p><strong>Execute the payload</strong>: Use <code>execve</code> or similar functions to execute the payload
directly from memory.</p></li></ol><p>We&rsquo;ll do this in Zig since ZYRA is written in Zig. So, let&rsquo;s get to some code:</p><blockquote><p>Some customary warning: If you&rsquo;re going to try this out, do it in your own fork so you don&rsquo;t disturb the original project.</p></blockquote><p>We&rsquo;ll first define a function to handle the in-memory execution that takes only
one parameter, the payload to be executed and uses the <code>noreturn</code> keyword since
the function will not return to the caller:</p><blockquote><p><strong>At the time of writing this, ZYRA uses Zig 0.14.0</strong></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>fn</span> executeInMemory(payload<span style=color:#f92672>:</span> []<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span>) <span style=color:#66d9ef>noreturn</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Our code will go here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span></code></pre></div><p>Next, we&rsquo;ll create the memory fd using <code>memfd_create</code>. This is super direct to do
in Zig:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>const</span> fd <span style=color:#f92672>=</span> std.os.linux.memfd_create(<span style=color:#e6db74>&#34;zyra_payload&#34;</span>, <span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><p>After creating the memory fd, we need to write our payload to it. We can use the
write function for this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span> _ <span style=color:#f92672>=</span> std.os.linux.write(@intCast(fd), payload.ptr, payload.len);
</span></span></code></pre></div><p>Now that the payload is written, it is not necessary to set it as executable.
<a href=https://www.kernel.org/doc/html/latest/userspace-api/mfd_noexec.html>Here is why</a> .</p><p>The next part is the most involving part so far. We need to prepare the arguments
and environment for the <code>execve</code> call. This involves creating C-style null-terminated
strings for the filename, args and environment variables.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>var</span> path_buf<span style=color:#f92672>:</span> [<span style=color:#ae81ff>64</span>]<span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>undefined</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> proc_path <span style=color:#f92672>=</span> std.fmt.bufPrint(<span style=color:#f92672>&amp;</span>path_buf,<span style=color:#e6db74>&#34;/proc/self/fd/{d}&#34;</span>,.{fd}) <span style=color:#66d9ef>catch</span> <span style=color:#66d9ef>unreachable</span>;
</span></span><span style=display:flex><span>path_buf[proc_path.len] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// Null-terminate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> path_cstr<span style=color:#f92672>:</span> [<span style=color:#f92672>*:</span><span style=color:#ae81ff>0</span>]<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> path_buf[<span style=color:#ae81ff>0</span>..proc_path.len<span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>].ptr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> argv_arr<span style=color:#f92672>:</span> [<span style=color:#ae81ff>2</span>]<span style=color:#f92672>?</span>[<span style=color:#f92672>*:</span><span style=color:#ae81ff>0</span>]<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> .{
</span></span><span style=display:flex><span>    path_cstr,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> argv<span style=color:#f92672>:</span> [<span style=color:#f92672>:</span><span style=color:#66d9ef>null</span>]<span style=color:#66d9ef>const</span> <span style=color:#f92672>?</span>[<span style=color:#f92672>*:</span><span style=color:#ae81ff>0</span>]<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> argv_arr[<span style=color:#ae81ff>0</span>.. <span style=color:#f92672>:</span><span style=color:#66d9ef>null</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> envp_arr<span style=color:#f92672>:</span> [<span style=color:#ae81ff>1</span>]<span style=color:#f92672>?</span>[<span style=color:#f92672>*:</span><span style=color:#ae81ff>0</span>]<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> .{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> envp<span style=color:#f92672>:</span> [<span style=color:#f92672>:</span><span style=color:#66d9ef>null</span>]<span style=color:#66d9ef>const</span> <span style=color:#f92672>?</span>[<span style=color:#f92672>*:</span><span style=color:#ae81ff>0</span>]<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> envp_arr[<span style=color:#ae81ff>0</span>.. <span style=color:#f92672>:</span><span style=color:#66d9ef>null</span>];
</span></span></code></pre></div><p>Here, we create a buffer for the path to the memory fd, and null-terminate it by
hand. There is probably a better way to do this in Zig. We then create arrays for
the args and envrironment variables, ensuring they are null-terminated as well.</p><p>Finally, we can call <code>execve</code> to execute the payload directly from memory:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span>_ <span style=color:#f92672>=</span> std.os.linux.execve(path_cstr, argv, envp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std.os.linux.exit(<span style=color:#ae81ff>127</span>);
</span></span></code></pre></div><p>Since <code>execve</code> does not return on success, we add an exit call after it to say
that if we reach that point, shit hit the fan.</p><p>Now, we can just call this function from main and pass the unpacked and decrypted payload.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span>executeInMemory(decrypted_payload);
</span></span></code></pre></div><p>To demo this, I packed my C2 agent with ZYRA, modified it to use the above function
for in-memory execution, and ran it on a Linux machine. The agent ran successfully.</p><p>Running strace on the process confirms that the payload runs from memory.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>m3lk0r@ubuntu:~$ strace -f ./rango
</span></span><span style=display:flex><span><span style=color:#ae81ff>1700</span>  execve<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;./rango&#34;</span>, <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;./rango&#34;</span><span style=color:#f92672>]</span>, 0x7ffd30677308 /* <span style=color:#ae81ff>28</span> vars*/<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1700</span>  execve<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/proc/self/fd/3&#34;</span>, <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;/proc/self/fd/3&#34;</span><span style=color:#f92672>]</span>, 0x7ffcaf034378 /* <span style=color:#ae81ff>0</span> vars */<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1701</span>  execve<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/usr/local/bin/hostname&#34;</span>, <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;hostname&#34;</span>, <span style=color:#e6db74>&#34;-I&#34;</span><span style=color:#f92672>]</span>,0x700d9af80038 /* <span style=color:#ae81ff>0</span> vars */<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> -1 ENOENT
</span></span><span style=display:flex><span><span style=color:#ae81ff>1701</span>  execve<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/bin//hostname&#34;</span>, <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;hostname&#34;</span>, <span style=color:#e6db74>&#34;-I&#34;</span><span style=color:#f92672>]</span>,0x700d9af80038 /* <span style=color:#ae81ff>0</span> vars */<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1701</span> +++ exited with <span style=color:#ae81ff>0</span> +++
</span></span></code></pre></div><p>This memfd_create technique bypasses traditional AV but may fail against EDR.
There are other techniques of doing in-memory execution in Linux. I may write
about those in the future, I&rsquo;m not promising anything though.</p></div></main></body></html>