<link rel=stylesheet href=/css/custom.css><!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><title>Safety in Zig: How Debug Allocator Works &#183; pop-ecx</title><meta name=description content><link type=text/css rel=stylesheet href=https://pop-ecx.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://pop-ecx.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://pop-ecx.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://pop-ecx.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><script src=https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js></script>
<script>function addDarkmodeWidget(){new Darkmode({label:"üåì",saveInCookies:!0,autoMatchOsTheme:!0,bottom:"32px",right:"32px",time:"0.3s",mixColor:"#fff",backgroundColor:"#fff"}).showWidget()}window.addEventListener("load",addDarkmodeWidget)</script></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=author-image><img src=/images/me.png alt="Author Image" class=author-image></div><div class=sidebar-about><a href=https://pop-ecx.github.io/><h1>pop-ecx</h1></a><p class=lead>Tech musings</p></div><div class=social-links><a href=https://github.com/pop-ecx target=_blank rel="noopener noreferrer"><img src=https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/github.svg width=24 height=24 alt=GitHub></a>
<a href=https://keybase.io/oliver_m target=_blank rel="noopener noreferrer"><img src=https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/keybase.svg width=24 height=24 alt=Keybase></a>
<a href=https://bsky.app/profile/pop-ecx.bsky.social target=_blank rel="noopener noreferrer"><img src=https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/bluesky.svg width=24 height=24 alt=Bluesky></a>
<a href=https://www.linkedin.com/in/oliver-mulwa target=_blank rel="noopener noreferrer"><img src=https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/linkedin.svg width=24 height=24 alt=LinkedIn></a></div><nav><ul class=sidebar-nav><li><a href=https://pop-ecx.github.io/>Home</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></nav><p>&copy; 2026. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Safety in Zig: How Debug Allocator Works</h1><time datetime=2026-01-06T10:55:00+0300 class=post-date>Tue, Jan 6, 2026</time><p>Zig is not a memory-safe language. It, however, provides some tools to help avoid
some memory safety issues. One of the key tools that help achieve this is the debug allocator.
The debug allocator is a special memory allocator that tracks memory allocations and deallocations,
helping identify memory leaks and other memory-related issues during development.</p><p>Since zig isn&rsquo;t a GC language and does not have a borrow checker, partly due to its design goals,
the debug allocator plays a crucial role in helping avoid some memory safety issues.</p><h4 id=what-the-debug-allocator-checks>What the debug allocator checks</h4><ol><li><strong>Memory Leaks</strong>: The debug allocator detects memory leaks with stack traces, making it easier to identify where memory was allocated but not freed.</li><li><strong>Double Free</strong>: Double frees are also detected, and prints all three traces (allocation, first free, second free).</li></ol><h4 id=how-debug-allocator-detects-memory-leaks>How Debug allocator detects memory leaks</h4><p>Before we dive into how zig does this, let&rsquo;s first get a TL;DR of Zig&rsquo;s detection strategy.</p><p>The debug allocator splits memory into small and large allocations.Small ones
are rounded up to the next power-of-two size class and packed into fixed-size pages (‚Äúbuckets‚Äù),
where each page tracks used slots with a simple bitset and hands out the next free
slot fast and easy. When a bucket fills up, it links to a new one, forming a list
that‚Äôs handy for leak checks.
Frees find their metadata by math and alignment tricks. Resizing only works if
you stay in the same size class.
Big allocations skip all this and go straight to the backing allocator, with their metadata tracked separately in a hash map.</p><p>Now that that&rsquo;s out of the way, let&rsquo;s see how zig implements leak detection.</p><blockquote><p>The following code snippet is taken from the debug allocator implementation in Zig&rsquo;s standard library (0.15.x).</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> detectLeaks(self<span style=color:#f92672>:</span> <span style=color:#f92672>*</span>Self) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> leaks <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (self.buckets, <span style=color:#ae81ff>0</span>..) <span style=color:#f92672>|</span>init_optional_bucket, size_class_index<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> optional_bucket <span style=color:#f92672>=</span> init_optional_bucket;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> slot_count <span style=color:#f92672>=</span> slot_counts[size_class_index];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> used_bits_count <span style=color:#f92672>=</span> usedBitsCount(slot_count);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (optional_bucket) <span style=color:#f92672>|</span>bucket<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            leaks <span style=color:#f92672>=</span> detectLeaksInBucket(bucket, size_class_index, used_bits_count) <span style=color:#66d9ef>or</span> leaks;
</span></span><span style=display:flex><span>            optional_bucket <span style=color:#f92672>=</span> bucket.prev;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> it <span style=color:#f92672>=</span> self.large_allocations.valueIterator();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (it.next()) <span style=color:#f92672>|</span>large_alloc<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (config.retain_metadata <span style=color:#66d9ef>and</span> large_alloc.freed) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> stack_trace <span style=color:#f92672>=</span> large_alloc.getStackTrace(.alloc);
</span></span><span style=display:flex><span>        log.err(<span style=color:#e6db74>&#34;memory address 0x{x} leaked: {f}&#34;</span>, .{
</span></span><span style=display:flex><span>            @intFromPtr(large_alloc.bytes.ptr), stack_trace,
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        leaks <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> leaks;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this code snippet, the <code>detectLeaks</code> function iterates though all the small
allocation buckets. It walks through each bucket and calls <code>detectLeaksInBucket</code> to
check which memory slots were allocated but not freed. The <code>detectLeaksInBucket</code>
reports the specific memory address that leaked along with its stack trace.</p><p>It then moves on to large allocations, doing the same check. If any leaks are found,
it logs the memory address and stack trace. After all is done, it returns whether
there were leaks found or not.</p><blockquote><p>Cursory reading of the same code in master branch (future 0.16.x) shows improvements
such as reporting the number of leaks instead of just a boolean. The core logic however
remains the same.</p></blockquote><p>Let&rsquo;s put this to the test with a simple example;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>const</span> std <span style=color:#f92672>=</span> @import(<span style=color:#e6db74>&#34;std&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> main() <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> debug_alloc <span style=color:#f92672>=</span> std.heap.DebugAllocator(.{ .verbose_log <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>, .safety <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span> }){};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> allocator <span style=color:#f92672>=</span> debug_alloc.allocator();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> result <span style=color:#f92672>=</span> debug_alloc.deinit();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> (result) {
</span></span><span style=display:flex><span>            .ok <span style=color:#f92672>=&gt;</span> {},
</span></span><span style=display:flex><span>            .leak <span style=color:#f92672>=&gt;</span> std.debug.print(<span style=color:#e6db74>&#34;Memory leak detected!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, .{}),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> leak <span style=color:#f92672>=</span> allocator.alloc(<span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>16</span>) <span style=color:#66d9ef>catch</span> <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    leak[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>99</span>;
</span></span><span style=display:flex><span>    std.debug.print(<span style=color:#e6db74>&#34;Leaked buffer first byte: {}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, .{leak[<span style=color:#ae81ff>0</span>]});
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>The debug allocator takes a struct config parameter, where you can set options like safety, stack trace frames etc.
You can check the full list of options in <a href=https://ziglang.org/documentation/0.15.1/std/#std.heap.debug_allocator.Config>the std lib documentation</a>.</p></blockquote><p>In this example, we are deliberately leaking memory by not freeing an allocated buffer.
When this is run, the leak will be detected and reported.</p><p>Running the code brings the following output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>m3lk0r@parrot:~$ zig build run
</span></span><span style=display:flex><span>anyzig: .minimum_zig_version <span style=color:#e6db74>&#39;0.15.1&#39;</span> pulled from <span style=color:#e6db74>&#39;/home/m3lk0r/allocdemo/build.zig.zon&#39;</span>
</span></span><span style=display:flex><span>anyzig: appdata <span style=color:#e6db74>&#39;/home/m3lk0r/.local/share/anyzig&#39;</span>
</span></span><span style=display:flex><span>anyzig: zig <span style=color:#e6db74>&#39;0.15.1&#39;</span> already exists at <span style=color:#e6db74>&#39;/home/m3lk0r/.cache/zig/p/N-V-__8AAN5NhBR0oTsvnwjPdeNiiDLtEsfXRHd1fv-R3TOv&#39;</span>
</span></span><span style=display:flex><span>info<span style=color:#f92672>(</span>gpa<span style=color:#f92672>)</span>: small alloc <span style=color:#ae81ff>16</span> bytes at 0x7f859a260000
</span></span><span style=display:flex><span>Byte: <span style=color:#ae81ff>99</span>
</span></span><span style=display:flex><span>error<span style=color:#f92672>(</span>gpa<span style=color:#f92672>)</span>: memory address 0x7f859a260000 leaked: 
</span></span><span style=display:flex><span>/home/m3lk0r/allocdemo/src/main.zig:15:33: 0x113e8a7 in main <span style=color:#f92672>(</span>main.zig<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    const leak <span style=color:#f92672>=</span> allocator.alloc<span style=color:#f92672>(</span>u8, 16<span style=color:#f92672>)</span> catch <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>                                ^
</span></span><span style=display:flex><span>/home/m3lk0r/.cache/zig/p/N-V-__8AAN5NhBR0oTsvnwjPdeNiiDLtEsfXRHd1fv-R3TOv/lib/std/start.zig:618:22: 0x113d9dd in posixCallMainAndExit <span style=color:#f92672>(</span>std.zig<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            root.main<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>                     ^
</span></span><span style=display:flex><span>/home/m3lk0r/.cache/zig/p/N-V-__8AAN5NhBR0oTsvnwjPdeNiiDLtEsfXRHd1fv-R3TOv/lib/std/start.zig:232:5: 0x113d271 in _start <span style=color:#f92672>(</span>std.zig<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    asm volatile <span style=color:#f92672>(</span>switch <span style=color:#f92672>(</span>native_arch<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    ^
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Memory leak detected!
</span></span></code></pre></div><h4 id=how-debug-allocator-detects-double-frees>How debug allocator detects double frees</h4><p>This is the snippet from Zig&rsquo;s source code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>fn</span> reportDoubleFree(ret_addr<span style=color:#f92672>:</span> <span style=color:#66d9ef>usize</span>, alloc_stack_trace<span style=color:#f92672>:</span> StackTrace, free_stack_trace<span style=color:#f92672>:</span> StackTrace) <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> addresses<span style=color:#f92672>:</span> [stack_n]<span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> @splat(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> second_free_stack_trace<span style=color:#f92672>:</span> StackTrace <span style=color:#f92672>=</span> .{
</span></span><span style=display:flex><span>        .instruction_addresses <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>addresses,
</span></span><span style=display:flex><span>        .index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    std.debug.captureStackTrace(ret_addr, <span style=color:#f92672>&amp;</span>second_free_stack_trace);
</span></span><span style=display:flex><span>    log.err(<span style=color:#e6db74>&#34;Double free detected. Allocation: {f} First free: {f} Second free: {f}&#34;</span>, .{
</span></span><span style=display:flex><span>        alloc_stack_trace, free_stack_trace, second_free_stack_trace,
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function basically captures the stack traces for the allocation, first free, and second free events.
It then logs an error message that includes all three stack traces.</p><blockquote><p>Master branch (future 0.16.x) shows a similar function with some improvements
such as using <code>@BranchHint(.cold)</code> to express that this code path is unlikely to be executed
so optimizations to other branches can be prioritized,
and some better logging formatting. The core logic remains the same.</p></blockquote><p>To see this in action, let&rsquo;s modify our previous example to include a double free:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> main() <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> debug_alloc <span style=color:#f92672>=</span> std.heap.DebugAllocator(.{ .verbose_log <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>, .safety <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span> }){};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> allocator <span style=color:#f92672>=</span> debug_alloc.allocator();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> result <span style=color:#f92672>=</span> debug_alloc.deinit();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> (result) {
</span></span><span style=display:flex><span>            .ok <span style=color:#f92672>=&gt;</span> {},
</span></span><span style=display:flex><span>            .leak <span style=color:#f92672>=&gt;</span> std.debug.print(<span style=color:#e6db74>&#34;Memory leak detected!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, .{}),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> leak <span style=color:#f92672>=</span> allocator.alloc(<span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>16</span>) <span style=color:#66d9ef>catch</span> <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    leak[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>99</span>;
</span></span><span style=display:flex><span>    std.debug.print(<span style=color:#e6db74>&#34;Byte: {}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, .{leak[<span style=color:#ae81ff>0</span>]});
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//Note: We are freeing to patch the memory leak from previous example
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>defer</span> allocator.free(leak);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> df <span style=color:#f92672>=</span> allocator.alloc(<span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>16</span>) <span style=color:#66d9ef>catch</span> <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    df[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>    std.debug.print(<span style=color:#e6db74>&#34;byte: {}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, .{df[<span style=color:#ae81ff>0</span>]});
</span></span><span style=display:flex><span>    <span style=color:#75715e>//Now we do a double free
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    allocator.free(df);
</span></span><span style=display:flex><span>    allocator.free(df);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When you run this code, a double free will be detected and reported:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>m3lk0r@parrot:~$ zig build run
</span></span><span style=display:flex><span>anyzig: .minimum_zig_version <span style=color:#e6db74>&#39;0.15.1&#39;</span> pulled from <span style=color:#e6db74>&#39;/home/m3lk0r/allocdemo/build.zig.zon&#39;</span>
</span></span><span style=display:flex><span>anyzig: appdata <span style=color:#e6db74>&#39;/home/m3lk0r/.local/share/anyzig&#39;</span>
</span></span><span style=display:flex><span>anyzig: zig <span style=color:#e6db74>&#39;0.15.1&#39;</span> already exists at <span style=color:#e6db74>&#39;/home/m3lk0r/.cache/zig/p/N-V-__8AAN5NhBR0oTsvnwjPdeNiiDLtEsfXRHd1fv-R3TOv&#39;</span>
</span></span><span style=display:flex><span>info<span style=color:#f92672>(</span>gpa<span style=color:#f92672>)</span>: small alloc <span style=color:#ae81ff>16</span> bytes at 0x7f8a52ea0000
</span></span><span style=display:flex><span>Byte: <span style=color:#ae81ff>99</span>
</span></span><span style=display:flex><span>info<span style=color:#f92672>(</span>gpa<span style=color:#f92672>)</span>: small alloc <span style=color:#ae81ff>16</span> bytes at 0x7f8a52ea0010
</span></span><span style=display:flex><span>Double free buffer first byte: <span style=color:#ae81ff>42</span>
</span></span><span style=display:flex><span>info<span style=color:#f92672>(</span>gpa<span style=color:#f92672>)</span>: small free <span style=color:#ae81ff>16</span> bytes at u8@7f8a52ea0010
</span></span><span style=display:flex><span>error<span style=color:#f92672>(</span>gpa<span style=color:#f92672>)</span>: Double free detected. Allocation: 
</span></span><span style=display:flex><span>/home/m3lk0r/allocdemo/src/main.zig:20:31: 0x113eb15 in main <span style=color:#f92672>(</span>main.zig<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    const df <span style=color:#f92672>=</span> allocator.alloc<span style=color:#f92672>(</span>u8, 16<span style=color:#f92672>)</span> catch <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>                              ^
</span></span><span style=display:flex><span>/home/m3lk0r/.cache/zig/p/N-V-__8AAN5NhBR0oTsvnwjPdeNiiDLtEsfXRHd1fv-R3TOv/lib/std/start.zig:618:22: 0x113d9dd in posixCallMainAndExit <span style=color:#f92672>(</span>std.zig<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            root.main<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>                     ^
</span></span><span style=display:flex><span>/home/m3lk0r/.cache/zig/p/N-V-__8AAN5NhBR0oTsvnwjPdeNiiDLtEsfXRHd1fv-R3TOv/lib/std/start.zig:232:5: 0x113d271 in _start <span style=color:#f92672>(</span>std.zig<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    asm volatile <span style=color:#f92672>(</span>switch <span style=color:#f92672>(</span>native_arch<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    ^
</span></span><span style=display:flex><span> First free: 
</span></span><span style=display:flex><span>/home/m3lk0r/allocdemo/src/main.zig:24:19: 0x113edef in main <span style=color:#f92672>(</span>main.zig<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    allocator.free<span style=color:#f92672>(</span>df<span style=color:#f92672>)</span>; // first free 
</span></span><span style=display:flex><span>                  ^
</span></span><span style=display:flex><span>/home/m3lk0r/.cache/zig/p/N-V-__8AAN5NhBR0oTsvnwjPdeNiiDLtEsfXRHd1fv-R3TOv/lib/std/start.zig:618:22: 0x113d9dd in posixCallMainAndExit <span style=color:#f92672>(</span>std.zig<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            root.main<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>                     ^
</span></span><span style=display:flex><span>/home/m3lk0r/.cache/zig/p/N-V-__8AAN5NhBR0oTsvnwjPdeNiiDLtEsfXRHd1fv-R3TOv/lib/std/start.zig:232:5: 0x113d271 in _start <span style=color:#f92672>(</span>std.zig<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    asm volatile <span style=color:#f92672>(</span>switch <span style=color:#f92672>(</span>native_arch<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    ^
</span></span><span style=display:flex><span> Second free: 
</span></span><span style=display:flex><span>/home/m3lk0r/allocdemo/src/main.zig:25:19: 0x113ee58 in main <span style=color:#f92672>(</span>main.zig<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    allocator.free<span style=color:#f92672>(</span>df<span style=color:#f92672>)</span>; // second free
</span></span><span style=display:flex><span>                  ^
</span></span><span style=display:flex><span>/home/m3lk0r/.cache/zig/p/N-V-__8AAN5NhBR0oTsvnwjPdeNiiDLtEsfXRHd1fv-R3TOv/lib/std/start.zig:618:22: 0x113d9dd in posixCallMainAndExit <span style=color:#f92672>(</span>std.zig<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            root.main<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>                     ^
</span></span><span style=display:flex><span>/home/m3lk0r/.cache/zig/p/N-V-__8AAN5NhBR0oTsvnwjPdeNiiDLtEsfXRHd1fv-R3TOv/lib/std/start.zig:232:5: 0x113d271 in _start <span style=color:#f92672>(</span>std.zig<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    asm volatile <span style=color:#f92672>(</span>switch <span style=color:#f92672>(</span>native_arch<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    ^
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>info<span style=color:#f92672>(</span>gpa<span style=color:#f92672>)</span>: small free <span style=color:#ae81ff>16</span> bytes at u8@7f8a52ea0000
</span></span></code></pre></div><p>The output is a bit long, but that&rsquo;s the point; detailed stacktraces for all three events are provided.</p><h3 id=conclusion>Conclusion</h3><p>The debug allocator in zig is a powerful tool for ensuring you dodge some common memory pitfalls.
It is however noteworthy that the allocator is meant to be used only in development. Using it in
production can lead to performance costs due to its overhead. Once you
are confident your code is solid, switch to a more efficient allocator for production builds.</p><p>There are other classes of memory issues and safety in general that the debug allocator does not cover.
Some are covered by release mode safety checks, while others can be caught by some plugins/tools.
Those will be covered in future blogs ü§û.</p></div></main></body></html>