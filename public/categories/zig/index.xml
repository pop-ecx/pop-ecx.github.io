<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>zig on pop-ecx</title><link>https://pop-ecx.github.io/categories/zig/</link><description>Recent content in zig on pop-ecx</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 06 Jan 2026 10:55:00 +0300</lastBuildDate><atom:link href="https://pop-ecx.github.io/categories/zig/index.xml" rel="self" type="application/rss+xml"/><item><title>Safety in Zig: How Debug Allocator Works</title><link>https://pop-ecx.github.io/safety-in-zig-how-debug-allocator-works/</link><pubDate>Tue, 06 Jan 2026 10:55:00 +0300</pubDate><guid>https://pop-ecx.github.io/safety-in-zig-how-debug-allocator-works/</guid><description>Zig is not a memory-safe language. It, however, provides some tools to help avoid some memory safety issues. One of the key tools that help achieve this is the debug allocator. The debug allocator is a special memory allocator that tracks memory allocations and deallocations, helping identify memory leaks and other memory-related issues during development.
Since zig isn&amp;rsquo;t a GC language and does not have a borrow checker, partly due to its design goals, the debug allocator plays a crucial role in helping avoid some memory safety issues.</description></item><item><title>Painless Guide to Linux in-Memory Execution</title><link>https://pop-ecx.github.io/painless-guide-to-linux-in-memory-execution/</link><pubDate>Thu, 04 Dec 2025 08:21:15 +0300</pubDate><guid>https://pop-ecx.github.io/painless-guide-to-linux-in-memory-execution/</guid><description>In-memory execution, a technique that allows programs to be run directly from memory without being written to disk. Over the past few weeks, I&amp;rsquo;ve been attempting to learn and understand this concept better. In a previous post, I explained my reasoning behind choosing ZYRA for obfuscation and packing. The key reason behind I could take it to whichever direction I wanted, should need arise.
Safe to say, need did arise. So in this post, we&amp;rsquo;ll modify ZYRA to support in-memory execution.</description></item><item><title>Zig as a drop-in replacement for C build systems</title><link>https://pop-ecx.github.io/zig-as-a-drop-in-c-replacement/</link><pubDate>Tue, 21 Oct 2025 09:28:15 +0300</pubDate><guid>https://pop-ecx.github.io/zig-as-a-drop-in-c-replacement/</guid><description>A while back I wrote a small neofetch-like program in Zig as a way to learn the language. I always knew Zig could interoperate with C, as I had earlier written a yara rules parser using treesitter and Zig.
Now I wanted to test my neofetch-like program in various environments, and one of those was st. St is a simple terminal emulator, part of the suckless tools. It is written in C, minimalistic and I generally liked using it.</description></item><item><title>Reflections on Writing a Mythic C2 Agent in Zig</title><link>https://pop-ecx.github.io/reflections-on-writing-a-mythic-c2-agent-in-zig/</link><pubDate>Mon, 14 Jul 2025 09:38:04 +0300</pubDate><guid>https://pop-ecx.github.io/reflections-on-writing-a-mythic-c2-agent-in-zig/</guid><description>Over the past couple of months, I&amp;rsquo;ve been writing a mythic C2 implant in zig. &amp;ldquo;Why?&amp;rdquo;, you ask. Well, it&amp;rsquo;s all part of my learning process. I also wanted to understand how C2 frameworks work and how zig can be used for offensive tooling.
There are lots of C2 frameworks out there and each has its own quirks and uniqueness. I happened to settle on Mythic. Mythic supports agents written in any language.</description></item></channel></rss>